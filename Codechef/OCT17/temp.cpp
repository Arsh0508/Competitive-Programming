#include <bits/stdc++.h>using namespace std ;#define inf 0x3f3f3f3f#define INF 1000111000111000111LL#define mod 1000000007#define pi acos(-1.0)#define eps 1e-8#define endl '\n'#define mp make_pair#define mt make_tuple#define pb push_back#define fi first#define se second#define all(cc) (cc).begin(),(cc).end()using lli = long long int ;using pii = pair<int, int> ;using vi = vector<int> ;using vb = vector<bool> ;using vvi = vector<vector<int>> ;using vlli = vector<long long int> ;using vpii = vector<pair<int, int>> ;const int N=1000005 ;const int blockSize=300 ;lli T, n, q, idx, L, R, l, r, x, y, B, s, u, d, ans ;char t ;vector<pair<lli, lli>> data ;vlli a, nxt, cnt, nge ;int get(int idx)  {    return idx/blockSize ;  }void init()  {    a.clear() ; nxt.clear() ; cnt.clear() ;    nge.clear() ; data.clear() ;    a.resize(n+2) ; nxt.resize(n+2) ; cnt.assign(n+2, 0) ;    nge.resize(n+2) ; data.resize(3500+2) ;  }void nextGreater(int l, int r)  {    stack<int> S ;    for (int i=r ; i>=l ; i--)      {        while(!S.empty() && a[S.top()]<=a[i]) S.pop() ;        if(!S.empty()) nge[i]=S.top() ;        else nge[i]=i ;        S.push(i) ;      }  }void preprocess()  {    for(int i=1 ; i<=n ; i++) nxt[i]=i ;    for(int i=0 ; i<=n ; i+=blockSize) nextGreater(max(i, 1), min(i+blockSize-1, (int)n)) ;    for(int i=n ; i>=1 ; i--) nxt[i]=nxt[nge[i]], cnt[i]=1+cnt[nge[i]] ;    for(int i=0 ; i<=n ; i+=blockSize)      {        s=max(i, 1) ;        u=a[s], d=a[s] ;        for(int j=s ; j<=min(s+blockSize-1, n) ; j++) u=max(a[j], u), d=min(a[j], d) ;        data[get(s)]=mp(u, d) ;      }  }void update(int idx, lli x)  {    a[idx]+=x ;    B=get(idx) ;    l=blockSize*B ; r=min(l+blockSize-1, n) ;    if(!l) l++ ;    nextGreater(l, r) ;    for(int i=r ; i>=l ; i--) nxt[i]=i, cnt[i]=0 ;    for(int i=r ; i>=l ; i--) nxt[i]=nxt[nge[i]], cnt[i]=1+cnt[nge[i]] ;    data[B]=mp(max(data[B].fi, a[idx]), min(data[B].se, a[idx])) ;  }int relax(int l, int r)  {    int res=0 ;    if(data[get(l)].fi<L) return 0 ;    for(int i=l ; i<=r ; i++)      if(a[i]>=L && a[nxt[i]]<R)        {          L=a[nxt[i]]+1 ;          return cnt[i] ;        }      else if(a[i]>=L && a[nxt[i]]>=R)        {          for(int j=i ; j<=r ; j++)            if(a[j]>=L)              {                L=a[j]+1, res++ ;                if(L>R) break ;              }          return res ;        }    return res ;  }int query(int idx)  {    B=get(idx) ;    ans=0 ;    for(int i=blockSize*B ; i<=n ; i+=blockSize)      if(L<=R) ans+=relax(max(i, idx), min(i+blockSize-1, (int)n)) ;      else return ans ;    return ans ;  }int main()  {    ios_base::sync_with_stdio (false) ; cin.tie(0) ; cout.tie(0) ;    cin>> T ;    while(T--)      {        cin>> n >> q ;        init() ;        for(int i=1;  i<=n ; i++) cin>> a[i] ;        preprocess() ;        for(int i=0 ; i<q ; i++)          {            cin>> t ;            if(t=='?')              {                cin>> idx >> L >> R ;                cout<< query(idx) << endl ;              }            else              {                cin>> idx >> x ;                update(idx, x) ;              }          }      }  }